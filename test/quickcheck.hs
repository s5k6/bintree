{- Testing some properties of the trees generated by `mkBinTree`.  See
[1] for documentation of the `QuickCheck` library. -}



module Main where

import BinTree
import Test.QuickCheck



newtype Case k v = Case { unCase :: (v,[(k, v)]) }

instance (Arbitrary k, Arbitrary v) => Arbitrary (Case k v) where
  arbitrary = sized mkCase

mkCase :: (Arbitrary k, Arbitrary v) => Int -> Gen (Case k v)

mkCase n = Case <$> ((,) <$> arbitrary <*> resize n arbitrary)



{- Property: The number of leaf nodes is equal to the number of values
used to construct the tree. -}

leafCount :: Char -> [(Float, Char)] -> Bool

leafCount v0 xs = size (mkBinTree v0 xs) == length xs + 1



{- Property: Serializing the tree (in-order DFS) reproduces the input
list.  This essentially subsumes `leafCount`. -}

identity :: Char -> [(Float, Char)] -> Bool

identity v0 xs = serialize (mkBinTree v0 xs) == (v0, xs)



{- Property: The tree is balanced, i.e., its maximum depth is limited to
log_2 n for n leaf nodes. -}

maxDepth :: Bool -> [(Double, Bool)] -> Bool

maxDepth v0 xs =
  (depth (mkBinTree v0 xs) :: Word)
  <=
  ceiling (log (fromIntegral $ length xs + 1) / log 2 :: Double)



{- Property: All values are found by the respective search. -}


newtype Id a = Id { unId :: a }

testSearch :: Word -> Bool

testSearch n = and $ map (\q -> unId (search q t) == q) [0..n]
  where
    t = mkBinTree (Id 0) [(i, Id i) | i <- [1..n]]



main :: IO ()

main = do
  putStrLn "\n"

  {- this is basically contained in `identity` below
  putStrLn "leafCount"
  qc leafCount
  --}

  --{-
  putStrLn "identity"
  qc identity
  --}

  --{-
  putStrLn "maxDepth"
  qc maxDepth
  --}

  --{-
  putStrLn "searching"
  qc testSearch
  --}

  where
    qc p = quickCheckWith stdArgs{ maxSize = 1000000, maxSuccess = 100 } p



{-
[1]: https://www.stackage.org/haddock/lts-18.27/QuickCheck-2.14.2/Test-QuickCheck.html
-}
